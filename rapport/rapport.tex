% !TeX encoding = UTF-8
\documentclass[11pt,a4paper,twoside,svgnames]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% ENCODAGES, LANGUES, AMS ET AUTRES 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage[english,frenchb]{babel}
%
\frenchbsetup{StandardLists=true} 
\usepackage{enumitem}
\usepackage{xspace}
\usepackage{amssymb,mathtools,pifont} 
\usepackage{xcolor}
\usepackage{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% ALGORITHMES ET PSEUDO-CODES
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%
\floatname{algorithm}{Algorithme}
\algrenewcommand\algorithmicrequire{\textbf{Données :}}
\algrenewcommand\algorithmicensure{\textbf{Résultat :}}
%
\algnewcommand\algorithmicto{\textbf{to}}
\algrenewtext{For}[3]{\algorithmicfor\ #1 $\gets$ #2 \algorithmicto\ #3 \algorithmicdo}
%
\algrenewcommand{\algorithmiccomment}[1]{\hfill{\color{Green}$\triangleright$ #1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MARGES, ENTÊTES ET PIEDS DE PAGE, TITRE
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\usepackage[hcentering=true,nomarginpar,textwidth=426.8pt,textheight=650.2pt,headheight=24pt]{geometry}
%
\usepackage{fancyhdr}
\fancypagestyle{plain}{
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
	\renewcommand{\footrulewidth}{0pt}}
\pagestyle{fancy}
	\fancyhf{}
	\fancyhead[LO]{SIO -- Printemps 2017}
	\fancyhead[RO,LE]{\thepage}
	\renewcommand{\headrulewidth}{0.4pt}
	\renewcommand{\footrulewidth}{0pt}
%
\usepackage{sectsty}
\allsectionsfont{\color{DarkOrange}}
\title{\color{Chocolate}\huge\bfseries SIO TP2\\Simulation de Monte-Carlo}
\author{Antoine \bsc{Friant}}
\date{\today}

\begin{document}

\maketitle

\section{Code source}

%L'application de ce TP1 a été intégralement réalisée en Java. Elle permet de générer des colorations de graphes selon les heuristiques LFS et DSATUR.\\
%
%Dans tout le programme, des tableaux de tableaux d'entiers on été utilisés pour modéliser les listes d'adjacence, plutôt que des LinkedList ou ArrayList, afin de réduire considérablement la quantité de mémoire utilisée. Grâce à cela, tous les tests peuvent être effectués avec moins de 2 Go de mémoire vive. Aucun accès par index n'est effectué dans une liste d'adjacence.\\
%
%Les index de toutes les structures utilisées sont numérotés de $0$ à $taille-1$. Il y a donc une conversion de la numérotation des sommets et des couleurs lors de la lecture et l'écriture des fichiers.
%
%\subsection{\texttt{main}}
%La fonction principale prend les noms de fichiers passés en argument du programme, puis lance une série de tests sur ceux-ci. Pour chaque fichier, elle récupère les listes d'adjacence du graphe, applique LFS et DSATUR un certain nombre de fois (défini dans la constante \texttt{NUMBER\textunderscore OF\textunderscore TRIES}), calcule les moyennes et médianes des temps d'exécution et les écarts-types, et enfin écrit le résultat des colorations dans des fichiers.
%
%\subsection{\texttt{lfs}}
%Il s'agit d'une traduction presque directe du pseudo-code rendu pour le TT1, car le pseudo code est en fait une traduction de ce code Java. Elle prend un tableau de tableaux d'entiers représentant les listes d'adjacence en argument, et renvoie un tableau d'entiers indiquant le numéro de la couleur de chaque sommet.\\
%
%En plus de la numérotation des index à adapter (0 à $taille-1$ au lieu de 1 à $taille$), un boucle a dû être ajoutée pour initialiser les \texttt{Stack} vides afin de les remplir ensuite lors du tri comptage.
%
%\subsection{\texttt{dsatur}}
%Cette fonction a subit des changements plus importants par rapport au pseudo code du TT1. Comme les couleurs sont numérotées à partir de 0, celle d'un sommet non coloré est désormais $-1$, et il faut initialiser le tableau de couleurs à cette valeur.\\
%\begin{figure}
%\includegraphics[scale=0.385]{ligne31.png}
%\caption{Extrait du pseudo code de DSATUR (TT1)}
%\label{fig:ligne31}
%\end{figure}
%
%Une erreur se manifeste à la ligne 31 du pseudo code (voir figure \ref{fig:ligne31}). Si la couleur choisie porte un numéro plus grand que le degré d'un sommet adjacent, la saturation ne sera pas incrémentée sur ce sommet adjacent. Pour résoudre ce problème il existe deux solutions faciles à implémenter :
%\begin{list}{$\bullet$}{}
%\item Agrandir le tableau de tableaux de booléens indiquant, pour chaque couleur de chaque sommet, si elle est disponible ou interdite, de sorte à ce que la disponibilité de \textbf{toutes} les couleurs du graphes soient listés pour chaque sommet. Il s'agit d'une solution gourmande en mémoire ($Ordre(G)\cdot \Delta(G)$ booléens dans un tableau de tableaux), mais qui reste rapide à l'exécution et à l'implémentation. C'est la correction choisie pour cette application.
%\item Convertir ce tableau de tableaux en tableau de listes de couleurs désordonnées. On conserve la même complexité spatiale, mais on perd du temps sur la recherche de la plus petite couleur disponible.
%\end{list}
%Pour redimensionner ces tableaux, un parcours des sommets est nécessaire au début de la fonction pour trouver $\Delta(G)$. On initialise alors tous les tableaux de booléens à $false$ avec une taille de $\Delta(G) + 1$, plutôt que \textit{degré du sommet} $+1$. La condition à la ligne 31 du pseudo code devient alors inutile, et la saturation des sommets s'incrémente correctement.
%
%\section{Utilisation}
%
%\begin{list}{$\bullet$}{}
%\item Mettre à jour Java RE.
%\item Ouvrir un terminal et naviguer jusqu'au dossier contenant l'exécutable "TP1.jar".
%\item Lancer la commande "\texttt{java -jar TP1.jar file1.txt file2.txt ...}" où fileX.txt sont les noms des fichiers contenant les graphes à colorer. S'ils ne sont pas dans le même dossier que TP1.jar, leur chemin d'accès (absolu ou relatif) est nécessaire.
%\item Le temps d'exécution de chaque fonction pour chaque fichier s'affiche dans la console.
%\item Les fichiers résultants (sommet-couleur) seront stockés à côté de l'exécutable et groupés dans le répertoire "results".
%\end{list}
%
\section{Résultats}
%Le tableau ci-dessous liste les degrés $n$ et les tailles $m$ des graphes, ainsi qu'un indicateur $\frac{2m}{n(n-1)}$. Plus un graphe ressemble à un graphe complet, plus cet indicateur est proche de 1. Le nombre de couleurs utilisées par chaque heuristique est également représenté.\\
%
%\begin{tabular}{l|r|r|r|r|r}
%    \multicolumn{1}{c}{\textbf{Fichier}} &\multicolumn{3}{|c}{\textbf{Graphe}} &\multicolumn{2}{|c}{\textbf{Nb coul.}}\\
%    
%   Col\textunderscore $\bullet$.txt&$n$ &$m$	&$\frac{2m}{n(n-1)}$	& LFS & DSat\\ \hline
%    
%	exemple	& 8	& 13	& 0.4643	& 4 	& 3\\
%	Hugo	& 80	& 254	& 0.0804	& 10	& 10\\
%	Queen8	& 64	& 728	& 0.3611 	& 13 	& 12\\
%	Queen10	& 100	& 1470	& 0.2970	& 17 	& 14\\
%	Horaire 	& 352	& 14612	& 0.2365	& 34 	& 27\\
%	R500\textunderscore 1	& 500	& 12458	& 0.0999	& 18 	& 16\\
%	R500\textunderscore 5	& 500	& 62624	& 0.5020	& 71 	& 65\\
%	R500\textunderscore 9	& 500	& 112437	& 0.9013	& 169 	& 170\\
%	Latin	& 900	& 307350	& 0.7597	& 213 	& 132\\
%	Tanzania	& 6117	& 1022321	& 0.0547	& 494 	& 471\\
%	Swiss 	& 13206	& 7446563	& 0.0854	& 983 	& 907\\
%	Vlsi1 	& 17845	& 26171065	& 0.1644	& 1437 	& 1254\\
%	Vlsi2 	& 29514	& 42000902	& 0.0964	& 1602 	& 1226
%
%\end{tabular}\\
%\begin{figure}[hb]
%\includegraphics[scale=0.85]{col-taille.png}
%\caption{Nombre de couleurs utilisées en fonction de la taille du graphe}
%\label{fig:col-taille}
%\end{figure}
%\clearpage
%Le temps d'exécution moyen et médian, ainsi que l'écart-type sur 1000 tests (100 tests pour Vlsi2), pour chaque fonction et pour chaque fichier de données, sont listés dans le tableau ci-dessous.\\
%
%\begin{tabular}{l|r|r|r|r|r|r|r}
%    \multicolumn{1}{c}{\textbf{Fichier}} &\multicolumn{1}{|c}{\textbf{Graphe}} &\multicolumn{2}{|c}{\textbf{T moyen [ms]}} &\multicolumn{2}{|c}{\textbf{$\sigma$ [ms]}} &\multicolumn{2}{|c}{\textbf{T méd. [ms]}}\\
%    
%   Col\textunderscore $\bullet$.txt	&$\frac{2m}{n(n-1)}$	&LFS	&DSat	& LFS & DSat& LFS & DSat\\ \hline
%    
%	exemple					& 0.4643	& 0.01 		& 0.01		& 0.05	& 0.07		& <0.01	& <0.01\\
%	Hugo					& 0.0804	& 0.05		& 0.03		& 0.03	& 0.05 		& 0.05	& 0.01\\
%	Queen8					& 0.3611 	& 0.06 		& 0.03		& 0.08	& 0.01 		& 0.04	& 0.02\\
%	Queen10					& 0.2970	& 0.02 		& 0.06		& <0.01	& 0.22		& 0.01	& 0.05\\
%	Horaire					& 0.2365	& 0.17	 	& 0.53		& 0.25	& 0.10		& 0.12	& 0.63\\
%	R500\textunderscore 1	& 0.0999	& 0.14 		& 0.77		& 0.09	& 0.09		& 0.13	& 0.81\\
%	R500\textunderscore 5	& 0.5020	& 0.31		& 1.16		& 0.04	& 0.07		& 0.29	& 1.12\\
%	R500\textunderscore 9	& 0.9013	& 0.69 		& 1.39		& 0.05	& 0.07		& 0.69	& 1.36\\
%	Latin					& 0.7597	& 2.17		& 2.94		& 0.13	& 0.23		& 2.06	& 2.87\\
%	Tanzania				& 0.0547	& 9.31		& 68.45		& 0.27	& 4.08		& 9.16	& 70.54\\
%	Swiss 					& 0.0854	& 86.57		& 299.50	& 5.80	& 31.41		& 86.31	& 280.18\\
%	Vlsi1 					& 0.1644	& 541.64	& 1019.94	& 49.59	& 152.76	& 517.68& 1074.15\\
%	Vlsi2 					& 0.0964	& 951.49	& 2353.81	& 104.96& 295.39	&1011.01& 2187.92
%
%\end{tabular}\\
%
%On constate que l'écart-type de certaines mesures est bien trop important pour les considérer comme fiables. Il convient donc de d'étudier la médiane plutôt que la moyenne, car elle est plus résistante aux valeurs atypiques.
%
%\begin{figure}[hb]
%\includegraphics[scale=0.85]{temps-taille.png}
%\caption{Médiane des temps d'exécution en ms en fonction de la taille du graphe}
%\label{fig:temps-taille}
%\end{figure}
%
\section{Discussion}
%
%On observe que le nombre de couleurs utilisées est lié la taille du graphe, et que l'aspect parabolique de la figure \ref{fig:col-taille} semble fortement dû au taux de complétion très bas des trois plus grands graphes. La meilleure coloration est dans presque tous les cas donnée par l'heuristique DSATUR, sauf sur le graphe le plus complet (90\%).\\
%
%Sur les graphes les plus petits, la fonction LFS est plus lente que DSATUR. Cela est très probablement dû au tri comptage qui constitue un traitement que seul LFS doit faire avant la coloration. Cependant, DSATUR étant en $O(n^2)$ et LFS en $O(n+m)$ dans le cas général, ce dernier est plus rapide sur des graphes dépassant 1000 arêtes. Comme l'illustre la figure \ref{fig:temps-taille}, cette différence de temps d'exécution ne fait que s'accroître à mesure que la taille du graphe augmente.

\end{document}
